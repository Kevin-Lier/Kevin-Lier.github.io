<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuusheng.github.io/</id>
    <title>AurorePolaire</title>
    <updated>2022-08-25T09:04:05.997Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuusheng.github.io/"/>
    <link rel="self" href="https://yuusheng.github.io/atom.xml"/>
    <subtitle>有点才华的理工男</subtitle>
    <logo>https://yuusheng.github.io/images/avatar.png</logo>
    <icon>https://yuusheng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, AurorePolaire</rights>
    <entry>
        <title type="html"><![CDATA[Vue script setup ts踩坑——v-model双向绑定]]></title>
        <id>https://yuusheng.github.io/vue-script-setup-ts-experience/</id>
        <link href="https://yuusheng.github.io/vue-script-setup-ts-experience/">
        </link>
        <updated>2022-03-09T02:50:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue-script-setup-ts踩坑v-model双向绑定">Vue script setup ts踩坑——v-model双向绑定</h1>
<blockquote>
<p>在Vue中我们常常使用v-model来绑定组件的内容，尤其在输入框中较为常见，但v-model的具体原理是什么，这篇文章就带你了解清楚。</p>
</blockquote>
<p>v-model的作用是用来双向绑定，他的实际原理是首先父组件传props给子组件，子组件接受到值之后如果值有变化（这里可以是input、click等造成props值发生改变），向父组件触发emit事件，使父组件同时改变自己的值。</p>
<p>下面直接上代码</p>
<blockquote>
<p>以下为目录结构</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/kevin-lier/picgo/img/20220309102158.png" alt="" loading="lazy"></figure>
</blockquote>
<h2 id="1-父组件传值">1、父组件传值</h2>
<p>父组件</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;VModel :fatherProps=&quot;fatherContents&quot;&gt;&lt;/VModel&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { ref } from 'vue'
import VModel from './components/VModel.vue'

const fatherContents = ref(&quot;this is father's content&quot;)
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;input type=&quot;text&quot; :childProps=&quot;fatherProps&quot; /&gt;
  &lt;hr /&gt;
  &lt;p&gt;{{ fatherProps }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
const props = defineProps({
  fatherProps: {
    type: String,
    default: '',
  },
})
&lt;/script&gt;

&lt;style&gt;
input {
  display: block;
}
&lt;/style&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/kevin-lier/picgo/img/20220309102443.png" alt="" loading="lazy"></figure>
<h2 id="2-子组件emit事件">2、子组件emit事件</h2>
<p>父组件</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;VModel :fatherProps=&quot;fatherContents&quot; @childInputChange=&quot;fatherResponse&quot;&gt;&lt;/VModel&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { ref } from 'vue'
import VModel from './components/VModel.vue'

const fatherContents = ref(&quot;this is father's content&quot;)

const fatherResponse = (data: string) =&gt; {
  console.log('father response the emit event, and the data is:', data)
  fatherContents.value = data
}
&lt;/script&gt;
</code></pre>
<p>子组件</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;input type=&quot;text&quot; :childProps=&quot;fatherProps&quot; @input=&quot;childEvent&quot; /&gt;
  &lt;hr /&gt;
  &lt;p&gt;{{ fatherProps }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
const props = defineProps({
  fatherProps: {
    type: String,
    default: '',
  },
})

// 定义触发事件
const emits = defineEmits&lt;{
  (e: 'childInputChange', data: string): void
}&gt;()

const childEvent = (e: Event) =&gt; {
  let childEventContent = (e.target as HTMLInputElement).value
  emits('childInputChange', childEventContent)
}
&lt;/script&gt;

&lt;style&gt;
input {
  display: block;
}
&lt;/style&gt;

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/kevin-lier/picgo/img/20220309103329.png" alt="" loading="lazy"></figure>
<p>此时我们已经可以看到子组件已经可以监听父组件的输入并且可以绑定输入的值了，此时我们已经实现了双向绑定。</p>
<p>接下来我们看看v-model</p>
<h2 id="3-v-model">3、v-model</h2>
<pre><code class="language-vue">  &lt;!-- &lt;VModel :fatherProps=&quot;fatherContents&quot; @childInputChange=&quot;fatherResponse&quot;&gt;&lt;/VModel&gt; --&gt;
  &lt;VModel v-model=&quot;fatherContents&quot;&gt;&lt;/VModel&gt;
</code></pre>
<p>当我们尝试把v-model的值改为fatherContents</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/kevin-lier/picgo/img/20220309103749.png" alt="" loading="lazy"></figure>
<p>我们会发现子组件此时已经无法接收到父组件传的props，这其实是由于v-model本身其实是一个modelValue，也就是我们子组件props的名字<strong>必须为modelValue</strong>才能接收到v-model传递的值</p>
<p>![image-20220309104011496](/Users/yuusheng/Library/Application Support/typora-user-images/image-20220309104011496.png)</p>
<p>接下来我们修改子组件代码</p>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- &lt;input type=&quot;text&quot; :childProps=&quot;fatherProps&quot; @input=&quot;childEvent&quot; /&gt; --&gt;
  &lt;input type=&quot;text&quot; :childProps=&quot;modelValue&quot; @input=&quot;childEvent&quot; /&gt;
  &lt;hr /&gt;
  &lt;!-- &lt;p&gt;{{ fatherProps }}&lt;/p&gt; --&gt;
  &lt;p&gt;modelValue: {{ modelValue }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
const props = defineProps({
  // fatherProps: {
  //   type: String,
  //   default: '',
  // },
  modelValue: {
    type: String,
    default: '',
  },
})

const emits = defineEmits&lt;{
  (e: 'childInputChange', data: string): void
}&gt;()

const childEvent = (e: Event) =&gt; {
  let childEventContent = (e.target as HTMLInputElement).value
  emits('childInputChange', childEventContent)
}
&lt;/script&gt;

&lt;style&gt;
input {
  display: block;
}
&lt;/style&gt;
</code></pre>
<p>![image-20220309104217593](/Users/yuusheng/Library/Application Support/typora-user-images/image-20220309104217593.png)</p>
<p>这时子组件已经接受到父组件传来的<code>father's content</code>，但是当我们输入内容时</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/kevin-lier/picgo/img/20220309104346.png" alt="" loading="lazy"></figure>
<p>发现modelValue的值并没有发生改变。</p>
<p>事实上，想要改变modelValue也需要特定的emit方法：<code>update:modelValue</code>。我们将emit中的方法名字改为update:modelValue</p>
<p>子组件：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- &lt;input type=&quot;text&quot; :childProps=&quot;fatherProps&quot; @input=&quot;childEvent&quot; /&gt; --&gt;
  &lt;input type=&quot;text&quot; :childProps=&quot;modelValue&quot; @input=&quot;childEvent&quot; /&gt;
  &lt;hr /&gt;
  &lt;!-- &lt;p&gt;{{ fatherProps }}&lt;/p&gt; --&gt;
  &lt;p&gt;modelValue: {{ modelValue }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
const props = defineProps({
  // fatherProps: {
  //   type: String,
  //   default: '',
  // },
  modelValue: {
    type: String,
    default: '',
  },
})

const emits = defineEmits&lt;{
  // (e: 'childInputChange', data: string): void
  (e: 'update:modelValue', data: string): void
}&gt;()

const childEvent = (e: Event) =&gt; {
  let childEventContent = (e.target as HTMLInputElement).value
  // emits('childInputChange', childEventContent)
  emits('update:modelValue', childEventContent)
}
&lt;/script&gt;

&lt;style&gt;
input {
  display: block;
}
&lt;/style&gt;

</code></pre>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/kevin-lier/picgo/img/20220309104648.png" alt="" loading="lazy"></figure>
<p>这时我们就成功实现了父子组件中的v-model双向绑定。</p>
<p>后：</p>
<p>以上问题是笔者在编写组件库时遇到的问题，网络上面的资料很多方法、变量名相同的，很容易搞混，这篇文章中所有变量名都有自己的含义，希望能帮到遇到同样问题的你。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript]]></title>
        <id>https://yuusheng.github.io/typescript/</id>
        <link href="https://yuusheng.github.io/typescript/">
        </link>
        <updated>2021-08-04T00:12:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="typescript">TypeScript</h1>
<ul>
<li>
<p>动态类型语言(Dynamically Typed Language)</p>
<p>运行期间自动分析变量类型</p>
</li>
<li>
<p>静态类型语言(Statically Typed Language)</p>
</li>
<li>
<p>数据变量类型在编译阶段</p>
</li>
</ul>
<p>TypeScript: JavaScript that scales</p>
<p>优点:</p>
<ul>
<li>程序更容易理解</li>
<li>效率更高</li>
<li>更少的错误</li>
<li>兼容性很好</li>
</ul>
<h2 id="命令行">命令行</h2>
<table>
<thead>
<tr>
<th>命令行</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>tsc greeter.ts</td>
<td>编译</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="数据类型">数据类型</h2>
<ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>number</li>
<li>string</li>
<li>any</li>
</ul>
<h3 id="数组">数组</h3>
<p>同类型数据</p>
<h3 id="元组">元组</h3>
<pre><code class="language-js">let person: [number, string] = [1,'polaire']
</code></pre>
<h3 id="interface">interface</h3>
<p>对对象的形状(shape)进行描述</p>
<p>Duck Typing：只要长得像鸭子，不管是什么东西，可以用它来描述各种概念上毫不相干的内容</p>
<pre><code class="language-js">interface IPerson {
  readonly id: number; //只读
  name: string;
  age?: number; //  可选
}
let polaire: IPerson = {
  id: 1,
  name: &quot;polaire&quot;,
  age: 1,
};
polaire.id = 123; //无法分配到 &quot;id&quot; ，因为它是只读属性
</code></pre>
<p>描述函数类型</p>
<pre><code class="language-js">const add = (x: number = 1, y: number, z?: number) =&gt; {
  if (typeof z === &quot;number&quot;) {
    return x + y + z;
  } else return x + y;
};

interface ISum {
  (x: number, y: number, z?: number): number;
}
let add2:ISum = add
</code></pre>
<p>描述类的属性和方法</p>
<pre><code class="language-js">interface IRadio {
  switchRadio(trigger: boolean): void;
}
interface IBattery {
  checkBatteryStatus(): void;
}
interface IRadioWithBattery extends IRadio, IBattery {}
class Car implements IRadio {
  switchRadio(trigger: boolean): void {}
}
class Cellphone implements IRadioWithBattery {
  switchRadio(trigger: boolean): void {
  }
  checkBatteryStatus(): void {
  }
}
</code></pre>
<h3 id="函数">函数</h3>
<p>js中函数是一等公民</p>
<p>ts中冒号后面都是在声明类型,和函数逻辑无关</p>
<h3 id="类型推论-联合类型和类型断言">类型推论 联合类型和类型断言</h3>
<pre><code class="language-js">// 声明联合类型
let numberOrString: number | string;
</code></pre>
<p>联合类型只能调用两者共有的方法或者属性，当我们必须要访问某个类型的方法时，我们要采用类型断言或者type guard。</p>
<pre><code class="language-js">// 类型断言
function getLength(input: string | number): number {
  const str = input as string;   // 类型断言
  if (str.length) {
    return str.length;
  } else {
    const number = input as number;
    return number.toString().length;
  }
}
 
// type guard  条件语句可以自动缩小类型范围  typeof
function getLength(input: string | number): number {
  if (typeof input === &quot;string&quot;) {
    return input.length;
  } else {
    return input.toString().length;
  }
}
</code></pre>
<h3 id="enum">enum</h3>
<pre><code class="language-js">enum Direction {
  Up,
  Down,
  Left,
  Right,
}
console.log(Direction.Up)
console.log(Direction[0])
</code></pre>
<h3 id="泛型">泛型</h3>
<p>在使用时才规定类型</p>
<pre><code class="language-js">function echo&lt;T&gt;(arg: T): T {
  return arg;
}
const result = echo('str')  // const result: &quot;str&quot;
const result: string = echo(&quot;str&quot;);

function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]];
}
const result = swap(['polaire',11])  // const result: [number, string]
</code></pre>
<p>约束泛型（用extends继承接口满足含有某个特定的属性）</p>
<pre><code class="language-js">interface IWithLength {
  length: number;
}
function echoWithArr&lt;T extends IWithLength&gt;(arg: T): T {
  console.log(arg.length);
  return arg;
}
</code></pre>
<p>泛型在类和接口的使用</p>
<p>泛型会指定在容器中的数据类型</p>
<pre><code class="language-js">class Queue&lt;T&gt; {
  private data = [];
  push(item: T) {
    return this.data.push(item);
  }
  pop(): T {
    return this.data.shift();
  }
}

const queue = new Queue&lt;number&gt;();
queue.push(1);
console.log(queue.pop().toFixed());

interface KeyPair&lt;T, U&gt; {
  key: T;
  value: U;
}

let kp1: KeyPair&lt;number, string&gt; = { key: 1, value: &quot;polaire&quot; };
</code></pre>
<h3 id="类型别名-type-aliase">类型别名 type aliase</h3>
<pre><code class="language-js">type StrOrNumber = string | number;
let result: StrOrNumber = &quot;123&quot;;
result = true; // 不能将类型“boolean”分配给类型“StrOrNumber”。
</code></pre>
<p>字面量：const str: 'name' = 'name'  新建一个str只能等于name</p>
<pre><code class="language-js">type Directions = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT'
let toWhere: Directions = 'UP'
</code></pre>
<p>交叉类型</p>
<pre><code class="language-js">interface IName {
  name: string;
}
type IPerson = IName &amp; { age: number };
let person: IPerson = { name: &quot;123&quot;, age: 123 };
</code></pre>
<h3 id="声明文件">声明文件</h3>
<h2 id="typescript变量声明">TypeScript变量声明</h2>
<h3 id="变量声明">变量声明</h3>
<ul>
<li>
<p>let	与JavaScript中var类似，但使用了<code>词法作用域</code>或<code>块作用域</code>，仅能在作用域内访问且不能在声明之前读或写（声明之前称为暂时性死区）。</p>
<blockquote>
<p>类型断言：let声明的any类型变量可以在调用时后面加上类型，这样编译器不会进行特殊的数据检查和解构</p>
</blockquote>
</li>
<li>
<p>const   声明之后不能再更改数值</p>
</li>
</ul>
<h3 id="解构">解构</h3>
<ol>
<li>数组解构</li>
</ol>
<pre><code class="language-js">let input = [1, 2];
let [first, second] = input;js
console.log(first); // outputs 1
console.log(second); // outputs 2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue]]></title>
        <id>https://yuusheng.github.io/vue/</id>
        <link href="https://yuusheng.github.io/vue/">
        </link>
        <updated>2021-07-30T03:01:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="命令行">命令行</h2>
<table>
<thead>
<tr>
<th>命令行</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>git clone</td>
<td>克隆git</td>
</tr>
<tr>
<td>vue create hello world</td>
<td>创建新项目</td>
</tr>
<tr>
<td>npm run serve</td>
<td>跑服务</td>
</tr>
<tr>
<td>ctrl+c</td>
<td>关闭服务</td>
</tr>
</tbody>
</table>
<blockquote>
<p>依赖：sass   compass(sass依赖包)  fastsave(快速点击)</p>
</blockquote>
<h3 id="git操作">git操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td>初始化</td>
</tr>
<tr>
<td>git add .</td>
<td>git push操作</td>
</tr>
<tr>
<td>git commit -m 'project-init'</td>
<td>~</td>
</tr>
<tr>
<td>git push</td>
<td>~</td>
</tr>
<tr>
<td>git pull</td>
<td>本地更新</td>
</tr>
<tr>
<td>git checkout index-swiper</td>
<td>分支转换到index-swiper</td>
</tr>
<tr>
<td>git status</td>
<td>查看git状态</td>
</tr>
<tr>
<td>git merge origin/index-icons</td>
<td>把index-icons合并到当前分支</td>
</tr>
</tbody>
</table>
<h2 id="vue项目开发">Vue项目开发</h2>
<p>单文件组件</p>
<ul>
<li>template  模板</li>
<li>script         逻辑</li>
<li>style            样式</li>
</ul>
<p>路由：根据网址不同返回不同的内容给用户</p>
<p>router-view：显示当前路由地址所显示的内容</p>
<p>router-link：页面跳转</p>
<h3 id="多页应用">多页应用</h3>
<ul>
<li>页面跳转====》返回html</li>
<li>优点：首屏时间快，SEO（搜索引擎优化）效果好</li>
<li>缺点：页面切换慢</li>
</ul>
<h3 id="单页应用">单页应用</h3>
<ul>
<li>Vue项目为单页应用<code>服务器渲染技术</code>，不会每次切换都请求html文件</li>
<li>页面跳转===》JS渲染</li>
<li>优点：页面切换快</li>
<li>缺点：首屏时间稍慢，SEO差</li>
</ul>
<p>移动端开发：</p>
<ul>
<li>border.css</li>
<li>reset.css</li>
<li>npm install fastclick --save</li>
<li>npm install stylus --save</li>
<li>npm install stylus-loader --save</li>
</ul>
<h3 id="axios">axios</h3>
<pre><code class="language-js">methods :{
    getHomeInfo () {
        axios.get('/news/index').then(this.getHomeInfoSucc)
    },
    getHomeInfoSucc(res) {
        res = res.data
        if(res.ret &amp;&amp; res.data)
        {
            const data = res.data
            this.city = data.city
            this.swiperList = data.swiperList
            this.iconList = data.iconList
            this.recommendList = data.recommendList
            this.weekendList = data.weekendList
        }
    }
},
mounted () {
    this.getHomeInfo()
}
</code></pre>
<h3 id="better-scroll">Better-scroll</h3>
<h2 id="引入vue">引入Vue</h2>
<pre><code class="language-js">	&lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="创建vue对象">创建Vue对象</h2>
<pre><code class="language-js">		var app = new Vue({
			el:'#app1',
			data:{
				content:&quot;hello world&quot;
			}
		})
</code></pre>
<p>在vue中只要改变vue对象的内容，显示内容会自动改变。</p>
<p>唯一有一种情况是使用Object.freeze(obj)  这会组织修改现有的property</p>
<h2 id="设计模式">设计模式</h2>
<p>MVVM设计模式</p>
<ol>
<li>
<p>传统开发（MVP）jQuery：<em>面向dom开发</em></p>
<p>M：Model</p>
<p>V：View</p>
<p>P： Presenter   70%-80%dom操作</p>
</li>
<li>
<p>MVVM设计模式：<em>面向数据开发</em></p>
<p>Model   -&gt;      传统JavaScript对象</p>
<p>ViewModel    Vue内置，不需要考虑</p>
<p>View      -&gt;      Dom</p>
</li>
</ol>
<h2 id="组件">组件</h2>
<p>每个组件就是页面上的一个区域</p>
<ul>
<li>全局组件:</li>
</ul>
<pre><code class="language-html">	&lt;ul&gt;
		&lt;todo-item v-bind:content=&quot;item&quot;
					v-for=&quot;item in list&quot;&gt;
		&lt;/todo-item&gt;
	&lt;/ul&gt;

	&lt;script&gt;
        var app = new Vue({
		el:&quot;#app&quot;,
		data:{
			list:['第一课内容','第二课内容'],
			inputValue:''
		},
		methods:{
			handleBtnClick:function(){
				this.list.push(this.inputValue)
				this.inputValue=&quot;&quot;
			}
		}
	})
	// 全局组件
	Vue.component(&quot;TodoItem&quot;,{
		props:['content'],
		template:&quot;&lt;li&gt;{{content}}&lt;/li&gt;&quot;
	})
	&lt;/script&gt;
</code></pre>
<ul>
<li>局部组件</li>
</ul>
<pre><code class="language-html">	&lt;script&gt;
        var app = new Vue({
		el:&quot;#app&quot;,
        components:{
            TodoItem: TodoItem
        },
		data:{
			list:['第一课内容','第二课内容'],
			inputValue:''
		},
		methods:{
			handleBtnClick:function(){
				this.list.push(this.inputValue)
				this.inputValue=&quot;&quot;
			}
		}
	})
	//局部组件
	var TodoItem = {
		props:['content'],
		template:&quot;&lt;li&gt;{{content}}&lt;/li&gt;&quot;
	}
	&lt;/script&gt;
</code></pre>
<p>父组件给子组件传值：v-bind（简写为冒号:）   在子组件中需要接收，用props</p>
<p>子组件通过$emit事件触发向上一层触发事件，父组件监听，监听后可以带出子组件的内容</p>
<p>组件作为另一组件的子组件时应该用is属性标注</p>
<p>组件中data必须是一个函数返回一个对象，否则组件不能复用，即一个组件改变会影响到其他所有的组件</p>
<h2 id="vue实例">Vue实例</h2>
<h3 id="生命周期钩子">生命周期钩子</h3>
<p><em>Vue实例在某一个时间点会自动执行的函数</em></p>
<h2 id="模板语法">模板语法</h2>
<p>v-text:  inner html改成Vue实例中的东西  与差值表达式相同</p>
<ul>
<li>在v-text与差值表达式中可以写入js表达式而不仅仅是变量</li>
</ul>
<p>v-html:  会输出真正的html</p>
<h2 id="计算属性和侦听器">计算属性和侦听器</h2>
<p>计算属性（computed）:用于简单运算  语法更简单</p>
<ul>
<li>
<p>计算属性拥有缓存机制，性能更好</p>
</li>
<li>
<p>计算属性的getter和setter</p>
<pre><code class="language-js">computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
</code></pre>
<p>通过这样的方式可以改变firstname和 lastname</p>
</li>
</ul>
<p>侦听器（watch）</p>
<h2 id="class与style绑定">Class与Style绑定</h2>
<p>通过对象与数组绑定</p>
<h2 id="条件渲染">条件渲染</h2>
<ul>
<li>v-if</li>
<li>v-else  必须紧跟在v-if后，否则不会被识别</li>
<li>v-else-if</li>
<li>v-show  与v-if基本相同，不同在于v-show为初始渲染而v-if为条件渲染，因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</li>
</ul>
<h2 id="列表渲染">列表渲染</h2>
<p>数组变异方法来操作数组才能改变数组内的值，不能直接用下标修改。</p>
<h3 id="变更方法">变更方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">push</td>
<td style="text-align:center">在数组结尾处添加新的元素</td>
<td style="text-align:center">新数组的长度</td>
</tr>
<tr>
<td style="text-align:center">pop</td>
<td style="text-align:center">从数组中删除最后一个元素</td>
<td style="text-align:center">被删除的值</td>
</tr>
<tr>
<td style="text-align:center">shift</td>
<td style="text-align:center">删除首个元素</td>
<td style="text-align:center">被删除的值</td>
</tr>
<tr>
<td style="text-align:center">unshift</td>
<td style="text-align:center">数组开头添加新元素</td>
<td style="text-align:center">新数组的长度</td>
</tr>
<tr>
<td style="text-align:center">splice</td>
<td style="text-align:center">1、从哪儿开始 2、删除几个 3、新的元素</td>
<td style="text-align:center">已删除项的数组</td>
</tr>
<tr>
<td style="text-align:center">sort</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">reverse</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="替换数组">替换数组</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">filter()</td>
<td>筛选</td>
</tr>
<tr>
<td style="text-align:center">concat()</td>
<td>合并</td>
</tr>
<tr>
<td style="text-align:center">slice()</td>
<td>切割</td>
</tr>
</tbody>
</table>
<p>Vue.set 可以改变对象中的内容</p>
<ul>
<li>Vue.set(vm.userInfo, &quot;address&quot;, &quot;beijing&quot;)</li>
<li>vm.$set(vm.userInfo, &quot;address&quot;, &quot;beijing&quot;)</li>
</ul>
<h2 id="动画效果">动画效果</h2>
<h2 id="sassscss">sass/scss</h2>
<ul>
<li>样式覆盖：::v-deep</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ECMAScript6-]]></title>
        <id>https://yuusheng.github.io/ecmascript6/</id>
        <link href="https://yuusheng.github.io/ecmascript6/">
        </link>
        <updated>2021-07-15T03:35:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="es6">ES6</h1>
<p>ES6是当前Javascript的语言标准，2015年发布，目前主流的JavaScript框架（Vue.js）都使用ES6编写。</p>
<p>ES6相对于ES5来说可以大大提高代码效率，同时让语法更加规范</p>
<h2 id="es6中声明常量更加方便仅使用const关键字">ES6中声明常量更加方便，仅使用<code>const</code>关键字</h2>
<h2 id="默认参数">默认参数</h2>
<pre><code class="language-js">//ES6
function f (x, y = 7, z = 42) {
    return x + y + z
}
f(1) === 50
//ES5
function f (x, y, z) {
    if (y === undefined)
        y = 7;
    if (z === undefined)
        z = 42;
    return x + y + z;
};
f(1) === 50;
</code></pre>
<h2 id="rest参数">rest参数</h2>
<p>rest参数是函数中的多余的参数数组，通过<code>...变量名</code>的形式访问，这样就不需要通过arguments对象</p>
<pre><code class="language-js">//ES6
function f (x, y, ...a) {
    return (x + y) * a.length
}
f(1, 2, &quot;hello&quot;, true, 7) === 9   
//a=[&quot;hello&quot;,true,7]
//arguments=[1, 2, &quot;hello&quot;, true, 7]

//ES5
function f (x, y) {
    var a = Array.prototype.slice.call(arguments, 2);
    return (x + y) * a.length;
};
f(1, 2, &quot;hello&quot;, true, 7) === 9;
</code></pre>
<h2 id="扩展运算符">扩展运算符</h2>
<p>扩展运算符在写项目逻辑的过程中非常实用，本身的语法类似于rest参数的反面：<code>...要展开的对象/数组</code>。通过这样的方式可以轻松实现复制数组、合并数组与结构赋值结合生成数组等。同时与箭头函数、filter  map方法结合也可以提高代码的可读性与艺术感</p>
<h2 id="箭头函数lambda表达式">箭头函数（lambda表达式）</h2>
<p>箭头函数适用于 与this无关的回调。定时器，数组方法的回调</p>
<p>不适合与this有关的回调，比如说与dom元素有关的事件回调，对象方法</p>
<p>(实参)=&gt; 返回值</p>
<pre><code class="language-js">//ES6
odds  = evens.map(v =&gt; v + 1)
pairs = evens.map(v =&gt; ({ even: v, odd: v + 1 }))
nums  = evens.map((v, i) =&gt; v + i)
//ES5
odds  = evens.map(function (v) { return v + 1; });
pairs = evens.map(function (v) { return { even: v, odd: v + 1 }; });
nums  = evens.map(function (v, i) { return v + i; });
</code></pre>
<blockquote>
<p>注意：箭头函数不会获取它们自己的arguments对象，需要通过借助不定参数和默认参数值等新特性来处理。</p>
</blockquote>
<h2 id="对象扩展-增强的对象属性">对象扩展-增强的对象属性</h2>
<h2 id="类与继承">类与继承</h2>
<pre><code class="language-js">class Shape {
    constructor (id, x, y) {
        this.id = id
        this.move(x, y)
    }
    move (x, y) {
        this.x = x
        this.y = y
    }
}
class Rectangle extends Shape {
    constructor (id, x, y, width, height) {
        super(id, x, y)
        this.width  = width
        this.height = height
    }
}
class Circle extends Shape {
    constructor (id, x, y, radius) {
        super(id, x, y)
        this.radius = radius
    }
}
</code></pre>
<p>ES6对类的声明更加简洁和专业，extends、super方法也让继承变得更加简单</p>
<blockquote>
<p>虽然js强调组件化，但是组件的开发依然无法离开面向对象存在。再加上ES6的静态方法，模块化让JS开发生产力更上一层楼。</p>
</blockquote>
<h2 id="遍历器">遍历器</h2>
<pre><code class="language-js">let fibonacci = {
    [Symbol.iterator]() {
        let pre = 0, cur = 1
        return {
           next () {
               [ pre, cur ] = [ cur, pre + cur ]
               return { done: false, value: cur }
           }
        }
    }
}

for (let n of fibonacci) {
    if (n &gt; 1000)
        break
    console.log(n)
}
</code></pre>
<p>for(let n of 循环对象)</p>
<p>遍历器要求被遍历对象是可遍历的，即拥有Symbol.iterator属性，原生具有Iterator接口的数据：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的arguments对象</li>
<li>NodeList对象</li>
</ul>
<h2 id="字符串模板">字符串模板</h2>
<pre><code class="language-js">//ES6
var customer = { name: &quot;Foo&quot; }
var card = { amount: 7, product: &quot;Bar&quot;, unitprice: 42 }
var message = `Hello ${customer.name},
want to buy ${card.amount} ${card.product} for
a total of ${card.amount * card.unitprice} bucks?`

//ES5
var customer = { name: &quot;Foo&quot; };
var card = { amount: 7, product: &quot;Bar&quot;, unitprice: 42 };
var message = &quot;Hello &quot; + customer.name + &quot;,\n&quot; +
&quot;want to buy &quot; + card.amount + &quot; &quot; + card.product + &quot; for\n&quot; +
&quot;a total of &quot; + (card.amount * card.unitprice) + &quot; bucks?&quot;;
</code></pre>
<p>ES6可以通过    <strong>`</strong>    来拼接字符串，可以避免使用过多的双引号</p>
<h2 id="数据结构">数据结构</h2>
<pre><code class="language-js">//ES6
let s = new Set()
s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;)
s.size === 2
s.has(&quot;hello&quot;) === true
for (let key of s.values()) // insertion order
    console.log(key)
//ES5
var s = {};
s[&quot;hello&quot;] = true; 
s[&quot;goodbye&quot;] = true; 
s[&quot;hello&quot;] = true;
Object.keys(s).length === 2;
s[&quot;hello&quot;] === true;
for (var key in s) // arbitrary order
    if (s.hasOwnProperty(key))
        console.log(s[key]);
</code></pre>
<h2 id="字符串方法">字符串方法</h2>
<ul>
<li>
<p>includes()</p>
</li>
<li>
<p>startsWith()</p>
</li>
<li>
<p>endsWith()</p>
<pre><code class="language-js">let s = 'Hello world!';

s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true

s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
</code></pre>
</li>
<li>
<p>repeat()</p>
<pre><code class="language-js">'x'.repeat(3) // &quot;xxx&quot;
'hello'.repeat(2) // &quot;hellohello&quot;
'na'.repeat(0) // &quot;&quot;
</code></pre>
</li>
<li>
<p>padStart()   头部尾部补全</p>
</li>
<li>
<p>padEnd()</p>
<pre><code class="language-js">'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba'
</code></pre>
</li>
<li>
<p>trimStart()   消除头部空格和尾部空格</p>
</li>
<li>
<p>trimEnd()</p>
<pre><code class="language-js">const s = '  abc  ';s.trim() // &quot;abc&quot;s.trimStart() // &quot;abc  &quot;s.trimEnd() // &quot;  abc&quot;
</code></pre>
</li>
</ul>
<h2 id="数值扩展">数值扩展</h2>
<ul>
<li>Number.isFinite()   是否有限</li>
<li>Number.isNaN()      (NaN ==&gt; Not a Number)</li>
<li>Number.parseInt()  float ==&gt; int</li>
<li>Number.parseFloat()  int ==&gt; float</li>
<li>Number.isInteger()   判断是否为整数</li>
<li>Number.isSafeInteger()   JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</li>
<li></li>
</ul>
<h2 id="symbol">Symbol</h2>
<pre><code class="language-js">	let game = {
        up: &quot;上&quot;,
        down: &quot;下&quot;
    }
    let methods = {
        up: Symbol(),
        down: Symbol()
    }
    game[methods.up] = function () {
        console.log(&quot;我要上升&quot;);
    }
    game[methods.down] = function () {
        console.log(&quot;我要下降&quot;);
    }
    console.log(game);
    let youxi = {
        name: &quot;狼人杀&quot;,
        say: '说',
        laugh: '笑',
        [Symbol('say')]: function (){
            console.log(&quot;我可以发言&quot;);
        },
        [Symbol('laugh')]: function () {
            console.log(&quot;我可以笑&quot;);
        }
    }
    console.log(youxi);
</code></pre>
<h2 id="set和map">Set和Map</h2>
<h3 id="set">Set</h3>
<p>声明:</p>
<pre><code class="language-js">let s = new Set();
</code></pre>
<p>方法:</p>
<ul>
<li>s.size	     个数</li>
<li>s.add()</li>
<li>s.delete()</li>
<li>s.has()</li>
<li>s.clear()</li>
</ul>
<p>可以通过for...of遍历</p>
<p>用途:</p>
<ul>
<li>
<p>数组去重</p>
</li>
<li>
<p>交集</p>
</li>
<li>
<p>并集</p>
</li>
<li>
<p>差集</p>
<pre><code class="language-js">    let arr = [1,2,3,4,1,3,2,4,5,2]
    let arr2 = [3,5,1,3,2,4]
    // 1、数组去重
    let result1 = [...new Set(arr)]  // [1,2,3,4,5]
    // 2、交集
    let result2 = [...new Set(arr)].filter(item =&gt; {
        let s2 = new Set(arr2)
        if(s2.has(item)){
            return true
        }else{
            return false
        }
    })
    let result2 = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item))
    // 3、并集
    let result3 = [...new Set([...arr,...arr2])]
    // 4、差集
    let result4 = [...new Set(arr)].filter(item =&gt; !(new Set(arr2).has(item)))
</code></pre>
</li>
</ul>
<h3 id="map">Map</h3>
<p>声明:</p>
<pre><code class="language-js">let m = new Map()

m.set('name','Kevin')

let key = {
    school: 'SHNU'
}
m.set(key,['北京','上海','深圳'])   // 对象作为key值
</code></pre>
<p>方法:</p>
<ul>
<li>m.size</li>
<li>m.delete()</li>
<li>m.get()</li>
<li>m.clear()</li>
</ul>
<h2 id="模块化">模块化</h2>
<p>优势:</p>
<ol>
<li>防止命名冲突</li>
<li>代码复用</li>
<li>高维护性</li>
</ol>
<p>CommonJS    =&gt;    NodeJS   Browserify</p>
<p>AMD            	=&gt;   requireJS</p>
<p>CMD				=&gt;    seaJS</p>
<p>模块化语法:</p>
<ul>
<li>
<p>export和import</p>
</li>
<li>
<p>分别暴露: 在数据声明前加export</p>
</li>
<li>
<p>统一暴露: export{ <code>暴露内容</code> , <code>暴露内容</code> }</p>
</li>
<li>
<p>默认暴露: export default{ }     调用时要多加一层default</p>
</li>
<li>
<p>通用导入: import * from '<code>路径</code>'</p>
</li>
<li>
<p>解构赋值: import {} from '<code>路径</code>'  如果有重名可以通过<code>as</code>起别名</p>
<p>默认形式: import {default as 名字} from &quot;<code>路径</code>&quot;</p>
</li>
<li>
<p>简便形式(只针对默认暴露生效): import <code>名字</code> from &quot;<code>路径</code>&quot;</p>
</li>
</ul>
<h2 id="filter和map">filter和map</h2>
<p>filter和map是两个数组方法，最初在ES5中提出，在项目开发中使用频繁，可以提高代码的简洁度、可读性</p>
<p>filter与map都会返回一个数组，使用时需要把返回值赋值给中间数组</p>
<pre><code class="language-js">	// map
    changeStatus(row, sta, staColor) {
        let result = this.result.map(_ =&gt; {
            if (_.number === row) {
                return { ..._, status: sta, statusColor: staColor /* 要改变的数据 */};
            }
            return _;
        });
        this.updateResult(result);
    }
	//filter
    Delete(n) {
      const result = this.result.filter(_ =&gt; _.number != n);
      this.updateResult(result);
    },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IU 5th Album 'LILAC']]></title>
        <id>https://yuusheng.github.io/iu-5th-album-lilac/</id>
        <link href="https://yuusheng.github.io/iu-5th-album-lilac/">
        </link>
        <updated>2021-03-25T12:10:16.000Z</updated>
        <content type="html"><![CDATA[<p><strong>IU终于发专辑啦啊啊啊啊好好听!</strong></p>
<p>已经期待了好久好久</p>
<p>分享下对于这支专辑的评价：</p>
<p>最喜欢的三首歌是<strong>Ah puh</strong>、<strong>LILAC</strong>、<strong>My sea</strong></p>
<p>Ah puh和LILAC是最喜欢的音乐风格，一听到就忍不住嘴角上扬的那种</p>
<p>My sea也是很喜欢的抒情歌，太太太爱弦乐了，大小提琴声音一出来就感觉超级好听。</p>
<p>不知道是网易云日推的原因还是韩语歌本身就是这样的，韩语歌的编曲大体上都十分喜欢，很喜欢有小小律动但是并不躁的音乐。</p>
<p>反正安利给每一个看到这篇文章的你，在曾经的一段时光里也一直到现在她的歌和性格都给我很大的安慰和鼓励，希望每一个读者一切都好！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript]]></title>
        <id>https://yuusheng.github.io/javascript/</id>
        <link href="https://yuusheng.github.io/javascript/">
        </link>
        <updated>2021-03-24T06:38:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="javascript">JavaScript</h1>
<h2 id="简介">简介</h2>
<ol>
<li>
<p>网页特效</p>
</li>
<li>
<p>服务端开发</p>
</li>
<li>
<p>命令行工具</p>
</li>
<li>
<p>桌面程序</p>
</li>
<li>
<p>APP</p>
</li>
<li>
<p>控制硬件-物联网</p>
</li>
<li>
<p>游戏开发</p>
<blockquote>
<p>弱类型  脚本语言</p>
</blockquote>
</li>
</ol>
<h2 id="组成">组成</h2>
<ul>
<li>
<p><strong>ECMAScript</strong>(网景): 语法规则</p>
</li>
<li>
<p><strong>DOM</strong>: 标签对象    <em>文档树模型</em></p>
</li>
<li>
<p><strong>BOM</strong>: 浏览器对象</p>
</li>
</ul>
<h2 id="书写位置">书写位置</h2>
<ul>
<li>写在行内</li>
<li>写在标签属性</li>
<li>写在单独文件</li>
</ul>
<p>（ps：开发标准为结构、行为、样式相分离，即HTML、js、css相分离）</p>
<h2 id="特点">特点</h2>
<p><strong>弱类型语言</strong>   类型会根据赋值情况进行变化</p>
<p>十六进制前加<strong>0x</strong></p>
<p>未赋值情况下类型为<strong>undefined</strong>(<strong>声明未赋值</strong>)    <em>Null表示赋值为<strong>空</strong></em></p>
<p>轮转时间片：将任务分为时间片，以时间片为单位完成任务。</p>
<h3 id="js执行">js执行</h3>
<p>语法分析：检测是否有低级语法错误</p>
<p>预编译（发生在函数执行的前一刻）</p>
<ol>
<li>自动全局：未经声明的变量直接赋值为全局变量（包括在函数中直接赋值的变量）。</li>
<li>声明的全局变量归window（全局的域）所有，相当于在window中添加了一个属性。</li>
</ol>
<p>预编译四部曲（函数体<em>AO</em>和全局<em>GO</em>都会发生）:</p>
<ol>
<li>创建AO/GO对象</li>
<li>找形参和变量声明，将变量和形参名作为AO/GO属性名，值为undefined</li>
<li>将实参值和形参值统一</li>
<li>在函数体里面找函数声明，赋值函数体</li>
</ol>
<p>在生成时会优先生成GO再生成AO</p>
<p>解释执行</p>
<h2 id="数据类型">数据类型</h2>
<ol>
<li>
<p>浮点数</p>
<p>可以使用科学计数法</p>
<p><strong>不要判断两个浮点数是否相等</strong></p>
</li>
<li>
<p>字符串类型:   'abc'   &quot;abc&quot;  <strong>单引号双引号都是字符串类型</strong></p>
<ul>
<li>
<p>为了区分html标签内属性值的双引号和外面的单引号</p>
</li>
<li>
<p>字符串长度: .length</p>
</li>
<li>
<p>字符串拼接用&quot;<strong>+</strong>&quot;   <em>两个数情况下</em>*+*<em>表示加减</em></p>
</li>
</ul>
</li>
<li>
<p>Boolen  布尔类型</p>
<ul>
<li><strong>undefined</strong>和<strong>Null</strong>是假</li>
<li>if判断不仅仅判断是否为真, 也判断变量中是否有数据</li>
</ul>
</li>
<li>
<p>类型转换</p>
<p>parseInt字符串转整数  <em>从字符串第一位开始检查, 从第一位非数字之后全部舍弃, 然后剩余内容转为整数</em></p>
</li>
<li>
<p>+,-等运算</p>
<pre><code class="language-js">str='500';
console.log(+str);   //取正
console.log(-str);   //取负
console.log(str - 0);
</code></pre>
</li>
</ol>
<h2 id="运算符">运算符</h2>
<h3 id="关系运算符">关系运算符</h3>
<ul>
<li>===   <strong>严格判断</strong>  同时判断数值和类型相同</li>
<li>!==    <strong>严格判断</strong>  同时判断数值和类型不同</li>
</ul>
<h2 id="数组">数组</h2>
<p><em>队列 栈 数组 集合</em></p>
<pre><code class="language-js">var arr = new Arry();	
var arr[1,2,3,4,5];
</code></pre>
<ul>
<li>数组中可以放任何类型的数据</li>
<li>for - in   可以输出下标(key) , 也可以输出对象的属性名字</li>
</ul>
<h2 id="函数">函数</h2>
<p><em>代码的封装</em></p>
<ul>
<li>
<p>function  函数名(){</p>
<p>//函数体</p>
<p>}</p>
<p><code>arguments</code>：实参列表</p>
</li>
<li>
<p>全局的方法或者变量都会被附加到window对象上, 所以一般不要这么做</p>
<pre><code class="language-js">function runFun(fn) {
    if (fn){
        fn();
    }
}					//匿名函数
runFun(function(){
    console.log(&quot;我是传递过去的参数&quot;);
})

//lambda表达式
function runFun(fn) {
    if (fn){
        fn();
    }
}					//匿名函数
runFun(()=&gt;{
    console.log(&quot;我是传递过去的参数&quot;);
})
</code></pre>
</li>
<li>
<p><strong>自调用函数/闭包!</strong></p>
<pre><code class="language-js">(function (形参) {
    console.log(&quot;你好呀&quot;)
})(实参);
</code></pre>
</li>
<li>
<p><strong>作用域</strong></p>
<p>在js中，流程控制的作用域、大括号的作用域都是失效的，所有变量都是<strong>全局变量</strong>。</p>
<p><strong>闭包</strong>中的变量只能在函数作用域中存在，即<strong>局部变量</strong>。</p>
</li>
</ul>
<h2 id="预解析">预解析</h2>
<ol>
<li>把变量的声明提升到当前作用域的最前面，但只会提升声明，不会提升赋值。</li>
<li>把函数的声明提升到当前作用域的最前面，但只会提升声明，不会提升调用。</li>
<li>先提升var，在提升function。</li>
</ol>
<p><em>方法覆盖变量</em></p>
<h2 id="对象">对象</h2>
<ol>
<li>
<p>json对象  字面量对象</p>
<pre><code class="language-js">(
    function () {
        var stus=[{id:1,name:'张三'},{id:2,name:&quot;lisi&quot;}];
        for (let i = 0; i &lt;stus.length; i++) {
            var element = stus[i];
            console.log(element.name);
        }
    }
)();
</code></pre>
</li>
<li>
<p>new Object</p>
<p><strong>.</strong>  有两个作用:  定义和调用，如果存在就调用，不存在就定义</p>
</li>
<li>
<p>自定义构造函数</p>
<p><strong>function</strong>  定义函数用小写，定义类首字母大写</p>
<pre><code class="language-js">function Student(id,name,age){
    this.id=id;
    this.name=name;
    this.age=age;
    this.show=function () {
        console,log(&quot;编号:&quot;+this.id+&quot;姓名:&quot;+this.name+&quot;年龄:&quot;+this.age);
    }
}

</code></pre>
</li>
<li>
<p>for - in 遍历对象</p>
<p>调用: <strong>stu.id</strong>  或者  <strong>stu[&quot;id&quot;]</strong></p>
<pre><code class="language-js">for (var arrayKey in stu) {
    if ((typeof stu[key])!=&quot;function&quot;){
        console.log(key+&quot;:&quot;+stu[key]);
    }
}
</code></pre>
</li>
<li>
<p>删除对象属性:   <strong>delete</strong></p>
</li>
</ol>
<h2 id="this">.this</h2>
<p>解析器再调用函数时每次都会向函数内部传递一个隐含的参数，这个参数就是this，this指向的是一个对象，这个对象我们称为函数执行的上下文对象，根据函数<code>调用方式</code>的不同，this会指定不同的对象</p>
<ol>
<li>函数调用：this指向window</li>
<li>方法调用：this指向object</li>
</ol>
<h2 id="常用对象">常用对象</h2>
<h3 id="math">Math</h3>
<table>
<thead>
<tr>
<th>Math.PI</th>
<th>圆周率</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.random()</td>
<td>生成随机数  (0--1且不等于1)</td>
</tr>
<tr>
<td>Math.random()</td>
<td>向下取整/向上取整</td>
</tr>
<tr>
<td>Math.round()</td>
<td>取整,四舍五入</td>
</tr>
<tr>
<td>Math.abs</td>
<td>绝对值</td>
</tr>
<tr>
<td>Math.max()/Math.min</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Math.sin()/Math.cos()</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.power()/Math.sqrt()</td>
<td>求指数次幂/求平方根</td>
</tr>
</tbody>
</table>
<h3 id="date对象">Date对象</h3>
<pre><code class="language-js">function Tools() {
    this.toStringDate = function (date) {
        var year = date.getFullYear();
        var month = date.getMonth()+1;
        var day = date.getDate();
        var hour = date.getHours();
        var minute = date.getMinutes();
        var second= date.getSeconds();
        return year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second;
    }
}
</code></pre>
<h3 id="array">Array</h3>
<ul>
<li>
<p>栈:先进的后出</p>
<p><strong>push()</strong></p>
<p><strong>pop()</strong>		取出数组的最后一项, 修改length属性</p>
</li>
<li>
<p>队列:先进的先出</p>
<p><strong>push()</strong></p>
<p><strong>shift()</strong>		取出数组中的第一个元素, 修改length属性</p>
<p><strong>unshift()</strong>	在数组最前面插入项,返回数组的长度</p>
</li>
<li>
<p>排序方法</p>
<p><strong>reverse()</strong> 	翻转数组</p>
<p><strong>sort()</strong>			即使是数组sort也是根据字符, 从小到大排序</p>
</li>
<li>
<p>操作方法</p>
<p><strong>concat()</strong>		把参数拼接到当前数组</p>
<p><strong>slice()</strong>			 从当前数组中截取一个新的数组,不影响原来的数组, 参数start从0开始, end从1开始</p>
<p><strong>splice()</strong>			参数start, deleteCount, options(要替换的项目)</p>
<p><strong>删除</strong>元素:   arr.splice(index,1)</p>
<p><strong>添加</strong>元素:   arr.splice(index,0,data)</p>
<p><strong>替换</strong>元素:    arr.splice(index,1,1data)</p>
</li>
<li>
<p>位置方法</p>
<p>indexOf()  lastIndexOf() 	如果没找到返回-1</p>
</li>
<li>
<p>迭代方法  不会修改原数组</p>
<p>every()  	filter()  	forEach()  	map()  	some()</p>
</li>
<li>
<p>方法将数组的所有元素连接到一个字符串中</p>
<p>join()</p>
</li>
</ul>
<h1 id="dom">DOM</h1>
<p><em>HTML中任何东西都是节点</em></p>
<h2 id="获取元素">获取元素</h2>
<ul>
<li>document.getElementById  这是最常用的获取元素的方法, 需要通过<strong>id</strong>获取, 在整个html页面中<strong>不能出现</strong>重复的id值</li>
<li>console.log(document.getElementById(&quot;div1&quot;));</li>
<li>当一个方法作为<strong>元素的事件绑定的方法</strong>时, 这时方法内部的<strong>this</strong>不再指向当前对象而是变成了<strong>事件源</strong>!</li>
</ul>
<pre><code class="language-js">    &lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot; id=&quot;img1&quot;&gt;
    &lt;script&gt;
        document.getElementById(&quot;img1&quot;).onclick = changeImage;
        function changeImage() {
            this.src=&quot;./images/2.jpg&quot;
        }
	&lt;/script&gt;
</code></pre>
<ul>
<li>在html中, <strong>元素的属性触发要晚于事件的触发</strong></li>
<li>如果事件触发的方法返回一个false, 代表<strong>终止</strong>属性触发的效果</li>
<li><strong>innerText</strong>获取元素中间的文本</li>
</ul>
<pre><code class="language-js">	&lt;a href=&quot;http://baidu.com&quot; id=&quot;a&quot;&gt;百度&lt;/a&gt;
    &lt;script&gt;
    		document.getElementById(&quot;a&quot;).onclick=function () {
            this.href=&quot;http://www.yuusheng.cn&quot;;
            this.innerText = &quot;博客园&quot;
            return  false;
        }
    &lt;/script&gt;
</code></pre>
<h3 id="获取元素的多种方式">获取元素的多种方式</h3>
<ol>
<li>
<pre><code class="language-js">function my$(id) {
     return  document.getElementById(id);
}
</code></pre>
</li>
<li>
<p>获取当前区域中的标签元素</p>
<p>getElementsByTagName(标签名)   在get方法中, Element如果加s表示获得一个数组, 不加s表示获得一个对象, 可以直接操作</p>
</li>
<li>
<p>getElementsByTagName(name)</p>
<p>Name是表单域中的<strong>表单元素</strong>的Name值</p>
</li>
<li>
<p>getElementsByClassName(class的值)</p>
<p>通过class名称获取元素</p>
</li>
</ol>
<h1 id="原型与原型链">原型与原型链</h1>
<h3 id="prototype">prototype</h3>
<p>在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。</p>
<pre><code class="language-js">function Person(age) {
    this.age = age       
}
Person.prototype.name = 'kavin'
var person1 = new Person()
var person2 = new Person()
console.log(person1.name) //kavin
console.log(person2.name)  //kavin
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151024134-512558007.png" alt="img" loading="lazy"></figure>
<h3 id="_proto_">_<em>proto</em>_</h3>
<p>这是每个对象(除null外)都会有的属性，叫做_<em>proto</em>_，这个属性会指向该对象的原型。</p>
<pre><code class="language-js">function Person() {

}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" loading="lazy"></figure>
<h3 id="constructor">constructor</h3>
<p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>
<pre><code class="language-js">function Person() {

}
console.log(Person===Person.prototype.constructor)  //true
</code></pre>
<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取</p>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151615691-1017611190.png" alt="img" loading="lazy"></figure>
<h3 id="实例与原型">实例与原型</h3>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<pre><code class="language-js">function Person() {

}

Person.prototype.name = 'Kevin';

var person = new Person();

person.name = 'Daisy';
console.log(person.name) // Daisy

delete person.name;
console.log(person.name) // Kevin
</code></pre>
<h3 id="原型的原型">原型的原型</h3>
<p>原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它</p>
<pre><code class="language-js">var obj = new Object();
obj.name = 'Kevin'
console.log(obj.name) // Kevin
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708152327825-11086376.png" alt="img" loading="lazy"></figure>
<h3 id="原型链">原型链</h3>
<blockquote>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p>
<p>——摘自《javascript高级程序设计》</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png" alt="img" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LINQ]]></title>
        <id>https://yuusheng.github.io/LINQ/</id>
        <link href="https://yuusheng.github.io/LINQ/">
        </link>
        <updated>2021-03-24T06:37:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="linq">LINQ</h1>
<h2 id="获取数据源">获取数据源</h2>
<pre><code class="language-C#">//queryAllCustomers is an IEnumerable&lt;Customer&gt;
var queryAllCustomers = from cust in customers
                        select cust;
</code></pre>
<blockquote>
<p>范围变量就像 <code>foreach</code> 循环中的迭代变量，但查询表达式中不会真正发生迭代。 当执行查询时，范围变量将充当对 <code>customers</code> 中每个连续的元素的引用。 由于编译器可以推断 <code>cust</code> 的类型，因此无需显式指定它。 可通过 <code>let</code> 子句引入其他范围变量。</p>
</blockquote>
<h2 id="筛选">筛选</h2>
<pre><code class="language-c#">where cust.City == &quot;London&quot; &amp;&amp; cust.Name == &quot;Devon&quot;
where cust.City == &quot;London&quot; || cust.City == &quot;Paris&quot;
</code></pre>
<h2 id="中间件排序">中间件排序</h2>
<p>​	<code>orderby</code> 子句根据要排序类型的默认比较器，对返回序列中的元素排序。</p>
<pre><code class="language-c#">orderby cust.Name ascending
</code></pre>
<h2 id="分组">分组</h2>
<p>​	<code>group</code> 子句用于对根据您指定的键所获得的结果进行分组。</p>
<pre><code class="language-c#">group cust by cust.City;
</code></pre>
<p>​	使用 <code>group</code> 子句结束查询时，结果将以列表的形式列出。 列表中的每个元素都是具有 <code>Key</code> 成员的对象，列表中的元素根据该键被分组。 在循环访问生成组序列的查询时，必须使用嵌套 <code>foreach</code> 循环。 外层循环循环访问每个组，内层循环循环访问每个组的成员。</p>
<p>​	如果必须引用某个组操作的结果，可使用 <code>into</code> 关键字创建能被进一步查询的标识符。 下列查询仅返回包含两个以上客户的组：</p>
<pre><code class="language-c#">group cust by cust.City into custGroup
</code></pre>
<h2 id="联接">联接</h2>
<p>​	联接操作在不同序列间创建关联，这些序列在数据源中未被显式模块化。 例如，可通过执行联接来查找所有位置相同的客户和分销商。 在 LINQ 中，<code>join</code> 子句始终作用于对象集合，而非直接作用于数据库表。</p>
<pre><code class="language-c#">var innerJoinQuery =
    from cust in customers
    join dist in distributors on cust.City equals dist.City
    select new { CustomerName = cust.Name, DistributorName = dist.Name };
</code></pre>
<h3 id="内部联接">内部联接</h3>
<pre><code class="language-c#">var innerJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID
    select new { ProductName = prod.Name, Category = category.Name }; //produces flat sequence
</code></pre>
<h3 id="分组联接-含有into表达式">分组联接  <em>含有<code>into</code>表达式</em></h3>
<pre><code class="language-c#">var innerGroupJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID into prodGroup
    select new { CategoryName = category.Name, Products = prodGroup };
</code></pre>
<p>​	还可以将分组联接的结果用作其他子查询的生成器：</p>
<pre><code class="language-c#">var innerGroupJoinQuery2 =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID into prodGroup
    from prod2 in prodGroup
    where prod2.UnitPrice &gt; 2.50M
    select prod2;
</code></pre>
<h2 id="等于运算符">等于运算符</h2>
<blockquote>
<p><code>join</code> 子句使用 <code>equals</code> 关键字而不是 <code>==</code> 运算符。 <code>equals</code> 关键字只能在 <code>join</code> 子句中使用，并且其与 <code>==</code> 运算符之间存在一个重要差别。 对于 <code>equals</code>，左键使用外部源序列，而右键使用内部源序列。 外部源仅在 <code>equals</code> 的左侧位于范围内，而内部源序列仅在其右侧位于范围内。</p>
</blockquote>
<h2 id="对源元素执行操作">对源元素执行操作</h2>
<blockquote>
<p>输出序列的每个字符串都将使用[字符串内插]进行格式设置。 内插字符串的左引号前有一个 <code>$</code>，并且可以在内插字符串内部的大括号内执行操作。 执行这些操作后，结果将进行串联。</p>
</blockquote>
<pre><code class="language-c#"> IEnumerable&lt;string&gt; output = 
            radii.Select(r =&gt; $&quot;Area for a circle with a radius of '{r}' = {r * r * Math.PI:F2}&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#]]></title>
        <id>https://yuusheng.github.io/CS/</id>
        <link href="https://yuusheng.github.io/CS/">
        </link>
        <updated>2021-03-20T08:13:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c基础语法">C#基础语法</h1>
<h2 id="一-net">一、.NET</h2>
<ul>
<li>.NET Framework(运行平台)</li>
<li>Visual Studio(开发工具)</li>
</ul>
<h2 id="二-输入与输出">二、输入与输出</h2>
<p>​	输入: Console.ReadLine(&quot;输入语句&quot;);  输入时只能输入字符串类型,如果需要其他类型则需要强制类型转换: 类型.Parse(Console.ReadLine());</p>
<p>​	输出:</p>
<ul>
<li>Console.WriteLine(&quot;输出语句&quot;);其中字符串可以用前面加<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi></mrow><annotation encoding="application/x-tex">的方法在字符串中直接加入变量</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span></span></span></span>&quot;**{i}&quot;</li>
<li>Console.Write(&quot;输出语句&quot;);  输出不换行</li>
</ul>
<h3 id="随机数">随机数</h3>
<pre><code class="language-cs">    Random random = new Random();
    int no = random.Next(1000, 2000);//max=2000,min=1000
</code></pre>
<h2 id="三-数组">三、数组</h2>
<h3 id="遍历数组">遍历数组</h3>
<pre><code class="language-c#">foreach (int j in n)
{

    int i = j - 100;
    Console.WriteLine($&quot;{j}&quot;);
}
</code></pre>
<h3 id="数组特征">数组特征:</h3>
<ul>
<li>数组长度固定</li>
<li>下标从0开始</li>
<li>数组中所有数据的类型相同</li>
</ul>
<h2 id="四-类">四、类</h2>
<p>​	<em>C#类的静态成员:类似于全局变量</em></p>
<p>​	<em>静态函数只能访问静态变量 无法访问非静态变量</em></p>
<p>类的成员：<strong>字段</strong>、<strong>属性</strong>、<strong>方法</strong></p>
<h3 id="访问修饰符">访问修饰符:</h3>
<ul>
<li>public</li>
<li><strong>private</strong>   <em>default</em></li>
<li>internal</li>
</ul>
<p><strong>字段</strong>一般设置为private，赋值和读取将通过属性来对字段赋值。这样可以保证数据的有效性与安全性。如果不需要对字段进行数据校验，仍然需要属性，这是C#的规范，对于调用者而言，调用者只能使用属性和方法，字段是不允许公开的。而当一个属性不需要对数据进行有效性检验时，可以使用缩写版属性：prop，自动属性和完整属性是完全一样的。</p>
<pre><code class="language-cs">class Student
{
    int id;
    string stuName;
    int age;

    public int Age   //属性
    {
        //访问器
        get
        {
            return age;
        }
        //访问器
        set
        {
            if (value&lt;0|| value&gt;125)
            {
                Console.WriteLine(&quot;您输入的年龄是非法的&quot;);
            }
            else
            {
                age = value;
            }
        }
    }
}
static void Main(string[] args)
{
    Student stu = new Student();
    stu.Age = 10;   			 //与public情况下对字段赋值相同
}
</code></pre>
<p>​	<strong>C#中类的继承用&quot;:&quot;</strong></p>
<p>​	抽象类存在的意义是一些类并不能被实例化, 但是需要被继承</p>
<pre><code class="language-c#">var shapes = new List&lt;Shape&gt;    // List&lt;Shap&gt;为一个Shap类的列表
        {
            new Rectangle(),
            new Triangle(),
            new Circle()
        };

</code></pre>
<p>​	类中成员初始化与运算符重载</p>
<pre><code class="language-c#">class Box
   {
      private double length;      // 长度
      private double breadth;     // 宽度
      private double height;      // 高度

      public double getVolume()
      {
         return length * breadth * height;
      }
      public void setLength( double len )
      {
         length = len;
      }

      public void setBreadth( double bre )
      {
         breadth = bre;
      }

      public void setHeight( double hei )
      {
         height = hei;
      }
      // 重载 + 运算符来把两个 Box 对象相加
      public static Box operator+ (Box b, Box c)
      {
         Box box = new Box();
         box.length = b.length + c.length;
         box.breadth = b.breadth + c.breadth;
         box.height = b.height + c.height;
         return box;
      }

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yuusheng.github.io//post-images/1617437554608.png" alt="" loading="lazy"></figure>
<p>如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。</p>
<h2 id="五-字符串">五、字符串</h2>
<ul>
<li>
<p>在C#中可以认为字符串是一个字符数组</p>
</li>
<li>
<p>字符串实际上是一个类  <em>暂存池</em></p>
</li>
<li>
<p>当两个字符串相同时，两个字符串会指向同一个内存地址</p>
<p>object.ReferenceEquals(str1,str2)   判断是否为同一个引用（对象）</p>
<p>==   基本类型可以判断内容是否相等，不需要调用Equals方法</p>
</li>
</ul>
<h3 id="字符串中的常用方法">字符串中的常用方法</h3>
<p><em>所有转换操作都不会对原始字符串产生影响</em></p>
<ul>
<li>.Length</li>
<li>.ToUpper() 转大写</li>
<li>.ToLower() 转小写</li>
<li>.Substring(startIndex)      .Substring(starIndex,length)</li>
<li>.IndexOf()</li>
<li>StringBuilder sb = new StringBuilder()  拼接字符串  用+来拼接字符串是非常耗费性能的。当字符串较多时，应使用新建StringBuilder对象调用Append(i)函数</li>
</ul>
<p>枚举：只能在枚举类中选择，不能出现不符合规则的值，保护了数据的有效性。</p>
<h2 id="六-值类型-引用类型和装箱拆箱">六、值类型、引用类型和装箱拆箱</h2>
<h3 id="值类型">值类型</h3>
<p><em>byte  short/char  int  long  float  double  decimal  bool  enum</em></p>
<p>值类型在赋值时传递的是<strong>数值</strong>，修改任意一个数值时另外一个<strong>不会发生变化</strong></p>
<h3 id="引用类型">引用类型</h3>
<p>string  object  array</p>
<p>赋值时传递的是地址，用new才会开辟空间，不然会指向另一个的地址</p>
<figure data-type="image" tabindex="2"><img src="https://yuusheng.github.io//post-images/1617437620704.png" alt="" loading="lazy"></figure>
<p>里式替换法则：父类型的变量可以装子类型的对象</p>
<p><strong>装箱</strong>：把值类型转换为引用类型</p>
<ul>
<li>object obj=1;</li>
</ul>
<p><strong>拆箱</strong>：把引用类型转换为值类型</p>
<ul>
<li>int c = (int)obj;   //比较浪费性能</li>
</ul>
<p>&quot;<strong>+</strong>&quot;拼接操作会开辟一个新的空间</p>
<h2 id="七-集合">七、集合</h2>
<p>特点</p>
<ul>
<li>可以添加或删除元素(可以伸缩)</li>
<li>集合中装的是object</li>
</ul>
<p>缺点:</p>
<ul>
<li>集合中装的是object  由于里式替换原则，不知道里面装的是什么，而拆箱和装箱的类型必须相同</li>
</ul>
<h2 id="八-集合泛型">八、集合泛型</h2>
<p>List<T> list = new List<T>;</p>
<ul>
<li>
<p>.Add()		添加</p>
</li>
<li>
<p>.Count()     数量</p>
</li>
<li>
<p>.Count(m=&gt;m%2=0)   偶数数量</p>
</li>
<li>
<p>.Remove(item)      对数据删除</p>
<p>对象或数组不能创造新的和原来数据相同的对象</p>
</li>
<li>
<p>.RemoveAt(index)   对下标进行删除</p>
</li>
<li>
<p>Clear()           清空</p>
</li>
<li>
<p>.Insert(index,item)     在某一索引下插入元素</p>
</li>
<li>
<p>.OrderBy(m=&gt;m)</p>
</li>
<li>
<p>.Sum()</p>
</li>
<li>
<p>.Max()</p>
</li>
<li>
<p>.Min()</p>
</li>
<li>
<p>.First(&quot;&quot;)   找到满足条件的第一个元素，如果没有找到会报错</p>
</li>
<li>
<p>.FirstOrDefault(&quot;&quot;)    没有会返回默认数据</p>
</li>
<li>
<p>.Any(&quot;&quot;)  判断是否至少有一个元素满足条件</p>
</li>
<li>
<p>.All(&quot;&quot;)    检查集合中的所有数据是否都满足条件</p>
</li>
<li>
<p>.Count(&quot;&quot;)  满足条件的所有元素的数量</p>
</li>
<li>
<p>.OrderBy(&quot;&quot;)   升序排序</p>
</li>
<li>
<p>.Take(n)  从头开始获取n个集合中的元素</p>
</li>
<li>
<p>Skip(n)    忽略前n个取后面的全部元素</p>
</li>
</ul>
<p>Lambada表达式:</p>
<p>​	变量 =&gt; 条件</p>
<p>var a = 1;       //a为int型，但是类型不会因为赋值而产生变化</p>
<h2 id="九-数据库操作">九、数据库操作</h2>
<figure data-type="image" tabindex="3"><img src="https://yuusheng.github.io//post-images/1617700371348.png" alt="" loading="lazy"></figure>
<ol>
<li>创建连接对象</li>
<li>创建指令对象
<ol>
<li>绑定连接对象</li>
<li>设置要执行的sql语句</li>
</ol>
</li>
<li>关闭连接</li>
</ol>
<pre><code class="language-cs">    //1. 创建连接
    SqlConnection con = new SqlConnection(@&quot;server=.;database=Login4;uid=sa;pwd=sa&quot;);
    con.Open();
    //2. 创建指令
    //2.1 绑定连接对象
    //2.2 设置要执行的sql语句
    SqlCommand cmd = new SqlCommand()
    {
        Connection = con,
        CommandText=&quot;&quot;
    };
    //执行sql并得到影响行数 insert update delete
    Console.WriteLine(cmd.ExecuteNonQuery());
    //cmd.ExecuteScalar()  执行查询语句,并返回第一行第一列的数据,其他数据会被忽略
    //一般用在判断账号密码是否正确
    Console.WriteLine((int)cmd.ExecuteScalar()==1?&quot;登录成功&quot;:&quot;账号密码有误&quot;);
    //cmd.ExecuteReader()  用来执行查询语句,返回所有的查询结果
    SqlDataReader dr = cmd.ExecuteReader();
    //DataReader的执行过程,只进,只读
    while (dr.Read())
    {
        Console.WriteLine($&quot;{dr[0]}{dr[&quot;Password&quot;]}{dr.GetDateTime(2).ToString(&quot;yyyy-MM-dd&quot;)}&quot;);
    }
    dr.Close();
    //3. 关闭连接
    con.Close();
</code></pre>
<h3 id="dbhelper">DBhelper</h3>
<p>普通类：属性需要通过实例化才能使用</p>
<p>静态：静态属性不需要实例化，要通过类名.方法/属性/字段调用。</p>
<p>类如果被标识为static，则类里的所有成员（字段、属性、方法）都必须是静态的。</p>
<h2 id="十-异常处理">十、异常处理</h2>
<p>C# 异常处理时建立在四个关键词之上的：<strong>try</strong>、<strong>catch</strong>、<strong>finally</strong> 和 <strong>throw</strong>。</p>
<ul>
<li><strong>try</strong>：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。</li>
<li><strong>catch</strong>：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。</li>
<li><strong>finally</strong>：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。</li>
<li><strong>throw</strong>：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。</li>
</ul>
<pre><code class="language-C#">try
{
   // 引起异常的语句
}
catch( ExceptionName e1 )
{
   // 错误处理代码
}
catch( ExceptionName e2 )
{
   // 错误处理代码
}
catch( ExceptionName eN )
{
   // 错误处理代码
}
finally
{
   // 要执行的语句
}
</code></pre>
<h2 id="十一-异步">十一、异步</h2>
<ul>
<li>当某个操作需要花费大量的时间进行处理，若是使用同步编程，那么程序在等待响应的时间内不能处理其他事物，这样效率比较低；而使用异步编程时，在进行等待相应的时间内，程序可以<strong>利用等待的时间处理其他事物</strong>，当得到响应时，再回到响应处继续执行，这样程序的<strong>效率会更高</strong>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客发展历程]]></title>
        <id>https://yuusheng.github.io/Development/</id>
        <link href="https://yuusheng.github.io/Development/">
        </link>
        <updated>2021-03-20T01:26:03.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<h3 id="20212-正式开始更新博客-使用gridea静态博客生成-typoramarkdown编辑器">2021.2  正式开始更新博客  使用Gridea(静态博客生成)  Typora(Markdown编辑器)</h3>
<p>​	缺点:连到GitHub pages上面经常无法同步,同步完全靠运气,定制性比较差</p>
<p>​	优点:有客户端,操作简单,学习成本较低</p>
</li>
<li>
<h3 id="2021315-博客增加自定义域名yuushengsite">2021.3.15  博客增加自定义域名yuusheng.site</h3>
</li>
<li>
<h3 id="2021323-博客迁移到wwwyuushengcn">2021.3.23  博客迁移到www.yuusheng.cn</h3>
</li>
<li>
<p>未完待续......</p>
<p>​</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小程序开发]]></title>
        <id>https://yuusheng.github.io/xiaochengxu/</id>
        <link href="https://yuusheng.github.io/xiaochengxu/">
        </link>
        <updated>2021-03-06T08:00:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="目录结构">目录结构</h2>
<ol>
<li>
<p>pages</p>
<p>index</p>
<blockquote>
<p>在page中新建文件夹:在app.json配置文件&quot;page&quot;中加入新的文件路径(https://yuusheng.github.io//post-images/1615017974562.png)</p>
</blockquote>
</li>
<li>
<p>app.js  <em>逻辑层</em></p>
<blockquote>
<p>&quot;pages&quot;中在最上面的会作为主页优先显示</p>
</blockquote>
</li>
<li>
<p>.json  <em>配置文件</em></p>
<ul>
<li>project.config.json   <em>项目配置文件</em></li>
</ul>
</li>
<li>
<p>.wxss <em>样式层  css 文件</em></p>
</li>
</ol>
<h2 id="组件">组件</h2>
<ol>
<li>
<p>view  <em>--div标签</em></p>
<p>属性: hover-class	<em>按下</em></p>
<p>​      	 hover-stop-propagation  <em>防止父子冒泡问题</em></p>
</li>
<li>
<p>text  <em>--行标签</em></p>
<p>属性: selectable</p>
<p>​			space			显示连续空格	类型string</p>
<p>​			decode 		 是否解码</p>
</li>
<li>
<p>image</p>
<pre><code class="language-html">   &lt;image src=&quot;&quot;&gt;&lt;/image&gt;
   &lt;!--
   ../退出一层目录
   ./ 
   /  顶层目录
   图像可以引入网络地址
   --&gt;
   &lt;image/&gt;
   &lt;image src=&quot;&quot; mode=&quot;&quot; show-menu-by-longpress&gt;&lt;/image&gt;
</code></pre>
</li>
<li>
<p>navigator     <em>超链接  块元素</em></p>
<pre><code class="language-html">  &lt;navigator url=&quot;&quot;&gt;&lt;/navigatot&gt;
  &lt;!--url中不要添加.js等后缀名 --&gt;
&lt;!-- open-type跳转到tabBar:switchTab   reLaunch
区别:switchTab不能传递参数--&gt;
</code></pre>
<p>无法访问外网,只能跳转到小程序.</p>
</li>
<li>
<p>scroll-view <em>--较常用</em></p>
<pre><code class="language-html">&lt;scroll-view scroll-left=&quot;150&quot; scroll-x&gt;
    &lt;view class=&quot;out&quot;&gt;
        &lt;view class=&quot;box&quot;&gt;&lt;image src=&quot;/u.jpg&quot; mode=&quot;aspectFit&quot; class=&quot;box&quot;&gt;&lt;/image&gt;&lt;/view&gt;
        &lt;view class=&quot;box&quot;&gt;222&lt;/view&gt;
        &lt;view class=&quot;box&quot;&gt;333&lt;/view&gt;
        &lt;view class=&quot;box&quot;&gt;444&lt;/view&gt;
        &lt;view class=&quot;box&quot;&gt;555&lt;/view&gt;
    &lt;/view&gt;
&lt;/scroll-view&gt;
</code></pre>
<pre><code class="language-css">.out{
  display: flex;flex-wrap: nowrap;
}
.box{width: 100px;height: 100px; background: gold;margin-right: 2px; flex: 0 0 100px;}
</code></pre>
</li>
<li>
<p>swiper</p>
<pre><code class="language-html">&lt;swiper class=&quot;banner&quot; indicator-dots autoplay interval=&quot;3000&quot; circular=&quot;true&quot; easing-function=&quot;linear&quot;&gt;
  &lt;swiper-item&gt;&lt;image src=&quot;/image/蓝发5.jpg&quot;&gt;&lt;/image&gt;&lt;/swiper-item&gt;
  &lt;swiper-item&gt;&lt;image src=&quot;/image/蓝发4.jpg&quot;&gt;&lt;/image&gt;&lt;/swiper-item&gt;
  &lt;swiper-item&gt;&lt;image src=&quot;/image/蓝发3.jpg&quot;&gt;&lt;/image&gt;&lt;/swiper-item&gt;
&lt;/swiper&gt;
</code></pre>
<pre><code class="language-css">.banner{height: 480px; width: 270px;}
.banner image{height: 100%; width: 100%;}
</code></pre>
</li>
<li>
<p>表单组件</p>
<p>​	见微信开放文档</p>
</li>
<li>
<p>其他类型组件</p>
<ol>
<li>
<p>icon</p>
<pre><code class="language-html">&lt;view style=&quot;padding:50px; text-align:center&quot;&gt;
  &lt;icon type=&quot;success&quot; size=&quot;100&quot;&gt;&lt;/icon&gt;
  &lt;view&gt;提交成功,感谢你的配合!&lt;/view&gt;
&lt;/view&gt;
</code></pre>
</li>
<li>
<p>progress</p>
<pre><code class="language-html">&lt;view style=&quot;padding:50px&quot;&gt;
  &lt;progress percent=&quot;60&quot; show-info font-size=&quot;15&quot; border-radius=&quot;10&quot; activeColor=&quot;pink&quot; backgroundColor=&quot;#ccc&quot;&gt;&lt;/progress&gt;
&lt;/view&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="框架">框架</h2>
<ol>
<li>
<p>小程序配置 <em>.json文件</em></p>
<ol>
<li>
<p>全局配置</p>
<pre><code class="language-json">    &quot;window&quot;:{
    	&quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,
    	&quot;navigationBarTitleText&quot;: &quot;我的小程序&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;white&quot;
    },

</code></pre>
<p>​     navigationBarBackgroundColor --只支持16进制颜色</p>
<p>​    &quot;tarBar&quot; <em>--Object</em></p>
<pre><code class="language-json">  &quot;tabBar&quot;: {
    &quot;color&quot;: &quot;#c30&quot;,
    &quot;selectedColor&quot;: &quot;#0ff&quot;,
    &quot;backgroundColor&quot;: &quot;#ccc&quot;,
    &quot;borderStyle&quot;: &quot;white&quot;,
    &quot;list&quot;: [
      {&quot;pagePath&quot;:&quot;page/index/index&quot;,
        &quot;text&quot;: &quot;首页&quot;,
        &quot;iconPath&quot;: &quot;images/home.png&quot;,
        &quot;selectedIconPath&quot;: &quot;images/homeh.png&quot;
      },
      {
        &quot;pagePath&quot;: &quot;pages/demo/demo&quot;,
        &quot;text&quot;: &quot;案例&quot;
      },
      {
        &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
        &quot;text&quot;: &quot;日志&quot;
      }
    ]
  },

</code></pre>
</li>
<li>
<p>页面配置</p>
</li>
<li>
<p>sitemap配置</p>
</li>
</ol>
</li>
<li>
<p>框架接口</p>
<ol>
<li>page  <em>--生命周期</em></li>
<li></li>
</ol>
</li>
<li>
<p>WXML语法参考</p>
<ol>
<li>
<p>数据绑定</p>
<pre><code class="language-html">&lt;view&gt;{{}}title&lt;/view&gt;
&lt;view&gt;{{arr[0]}} - {{arr[1]}} - {{arr[2]}}&lt;/view&gt;
&lt;view&gt;{{obj.name}} - {{obj.age}} - {{obj.gender}}&lt;/view&gt;
</code></pre>
<pre><code class="language-js">  data: {
    title:&quot;这是一个标题&quot;,//字符串
    arr:[&quot;平面设计&quot;,&quot;UI设计&quot;,&quot;web前端&quot;],//数组
    obj:{name:&quot;Kevin Li&quot;,age:18,gender:&quot;男&quot;}
  },//对象
</code></pre>
</li>
<li>
<p>列表渲染</p>
<pre><code class="language-html">&lt;view wx:for=&quot;{{array}}&quot;&gt;
  {{index}}: {{item.message}}
&lt;/view&gt;
&lt;!-- index表示索引值 item表示数组中的内容 --&gt;

&lt;!-- 
使用 wx:for-item 可以指定数组当前元素的变量名,
使用 wx:for-index 可以指定数组当前下标的变量名. 
--&gt;
&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}}: {{itemName.message}}
&lt;/view&gt;

</code></pre>
<pre><code class="language-js">  data: {
    array: [{
      message: 'foo',
    }, {
      message: 'bar'
    }]
  },
</code></pre>
</li>
<li>
<p>条件渲染</p>
<pre><code class="language-html">&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;\
&lt;!--js代码需要加{{}}--&gt;
</code></pre>
<pre><code class="language-html">&lt;view wx:if=&quot;{{length &gt; 5}}&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;{{length &gt; 2}}&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
&lt;!--if else必须连在一起,不能破坏连续性--&gt;

&lt;block wx:if=&quot;{{true}}&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
&lt;!--block标签可以用来包裹多个组件,但本身并不会在页面中渲染,包裹中的内容并不会下移一个层级--&gt;
</code></pre>
</li>
<li>
<p>模板</p>
</li>
<li>
<p>引用</p>
</li>
</ol>
</li>
<li>
<p>事件函数及setData用法</p>
<pre><code class="language-js">  myTap:function(res){
    var name=res.currentTarget.dataset.name
    this.setData({
      name:name
    })
  },
</code></pre>
<pre><code class="language-html">&lt;view bindtap=&quot;myTap&quot; data-name=&quot;suzy&quot; style=&quot;height:200rpx;width:200rpx;background:pink;&quot;&gt;{{name}}&lt;/view&gt;
</code></pre>
</li>
</ol>
<h2 id="api-小程序内置的方法">API   <em>--小程序内置的方法</em></h2>
<h3 id="基础">基础</h3>
<ol>
<li>系统</li>
</ol>
<h3 id="界面">界面</h3>
<ol>
<li>
<p>动画</p>
<pre><code class="language-js">    &lt;!--loading--&gt;
	wx.showLoading({
      title: '数据加载中...'
    })
    setTimeout(res=&gt;{
      wx.hideLoading()
    },1500)
	&lt;!--提交成功--&gt;
    wx.showToast({
      title: '提交成功',
    })
</code></pre>
</li>
<li></li>
</ol>
<h3 id="网络">网络</h3>
<p>​	wx.request</p>
<blockquote>
<p>假数据:</p>
</blockquote>
<pre><code class="language-js">  data: {
    datalist:[
      {title:&quot;iu回归&quot;,time:&quot;2021-3-25&quot;,src:&quot;/images/img1.jpg&quot;},
      {title:&quot;iu25日回归&quot;,time:&quot;2021-3-25&quot;,src:&quot;/images/img2.jpg&quot;},
      {title:&quot;iu3月25回归&quot;,time:&quot;2021-3-25&quot;,src:&quot;/images/img1.jpg&quot;}
    ]
  },
</code></pre>
<pre><code class="language-html">&lt;view class=&quot;out&quot;&gt;

  &lt;view class=&quot;row&quot; wx:for=&quot;{{datalist}}&quot;&gt;
    &lt;view class=&quot;pic&quot;&gt;
      &lt;image src=&quot;{{item.src}}&quot;&gt;&lt;/image&gt;
    &lt;/view&gt;

    &lt;view class=&quot;text&quot;&gt;
      &lt;view class=&quot;title&quot;&gt;{{item.title}}&lt;/view&gt;
      &lt;view class=&quot;time&quot;&gt;{{item.time}}&lt;/view&gt;
    &lt;/view&gt;
  &lt;/view&gt;

&lt;/view&gt;
</code></pre>
<pre><code class="language-css">.out{padding: 30rpx; box-sizing: border-box;}
.row{ display: flex; height: 150rpx; margin-bottom: 20rpx;}
.pic{flex: 2;}
.pic image{width:100%; height: 100%;}
.text{flex: 8; border-bottom: 1px solid #eee; padding-left: 10rpx; display: flex; flex-direction: column; justify-content: space-between;}
.text .title{font-size:38rpx;}
.text .time{color: #999;}
</code></pre>
<p>​</p>
<pre><code class="language-js">  nextPage:function(){
    this.data.num++
    this.getList(this.data.num);
  },
  getList:function(p=1){
    wx.request({
      url: '',
      data:{
        num=5,
        page:p
      },
      success:res=&gt;({
        resData:res.data
      })
    })
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    this.getList();
  },
</code></pre>
<h3 id="路由">路由</h3>
<p>​	与navigator类似,在标签中bindtap方法</p>
<ol>
<li>wx.switchTab  <em>--跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</em></li>
<li>wx.reLaunch  <em>--关闭所有页面，打开到应用内的某个页面</em></li>
<li>wx.redirectTo  <em>--关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</em></li>
<li>wx.navigateTo  <em>--保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 <strong>wx.navigateBack</strong>可以返回到原页面。</em></li>
<li>wx.navigateBack  <em>--关闭当前页面，返回上一页面或多级页面。可通过 <strong>getCurrentPages</strong> 获取当前的页面栈，决定需要返回几层</em></li>
</ol>
<h2 id="es6">ES6</h2>
<h3 id="const常量">const常量</h3>
<pre><code class="language-js">const a=123;		// 不能修改
</code></pre>
<h3 id="let块级变量">let块级变量</h3>
<p>​		只在块当中起作用,外界无法访问</p>
<h3 id="模板字面量">模板字面量</h3>
<p>​		字符串拼接和写模板使用反引号` 变量使用${}</p>
<h3 id="解构赋值">解构赋值</h3>
<pre><code class="language-js">    //数组解构
    var arr=[111,222,333,444];
    [a,b,,d]=arr
    console.log(a,b,d)
    //对象解构
    var data={
        name:&quot;张三&quot;,
        age:&quot;29&quot;,
        gender:&quot;男&quot;,
        job:&quot;开发&quot;
    }
    var{name,job}=data
    console.log(name,job)
</code></pre>
<h3 id="箭头函数">箭头函数</h3>
<p>箭头函数相当于匿名函数,并且简化了函数定义.()中放参数,没有参数就省略,箭头后面是函数体.ES6之前访问函数外面的this比较麻烦,箭头函数可以直接访问最外面的this,不需要转换</p>
<h3 id="对象中函数的声明">对象中函数的声明</h3>
<pre><code class="language-js">    var obj={
        user:&quot;张三&quot;,
        job(){
                return &quot;web前端开发&quot;
        }
    }
</code></pre>
<h3 id="for-of循环遍历">for-of循环遍历</h3>
<pre><code class="language-js">    var arr=[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;];
    for (var i of arr){
        console.log(i)
    }
</code></pre>
<h3 id="默认参数">默认参数</h3>
<pre><code class="language-js">    for (var i=0;i&lt;arr.length;i++){
        arr[i]=arr[i]+&quot;aiyou&quot;
    }

    var newArr=[]
    arr.forEach((item,idx)=&gt;{
        item=item+&quot;aiyou&quot;
        newArr.push(item)
    })
        
    var newArr=arr.map((item)=&gt;{
        return item+&quot;aiyou&quot;
    })
</code></pre>
<pre><code class="language-js">    function fun(x=0,y=2,z=true) {
        console.log(x,y,z);
    }
    fun(); //0  2  true
    fun(4,0,flase); //4  0  flase
</code></pre>
<h3 id="展开运算符">展开运算符</h3>
<pre><code class="language-js">        arr=[111,222,333]
        arr2=[&quot;aaa&quot;,&quot;bbb&quot;]
        var newarr=[...arr,...arr2]
</code></pre>
<p>​		...展开数组</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MVC]]></title>
        <id>https://yuusheng.github.io/mvc/</id>
        <link href="https://yuusheng.github.io/mvc/">
        </link>
        <updated>2021-02-24T09:31:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mvc结构"><strong>MVC结构</strong></h2>
<ol>
<li>App_Start</li>
</ol>
<ul>
<li>
<p>Bundleconfig:<u>打包器</u></p>
<blockquote>
<p>更新时按照固定的格式更换js文件</p>
</blockquote>
</li>
</ul>
<ul>
<li>FilterConfig:<u>过滤器</u></li>
<li>RouteConfig:<u>路由配置</u></li>
</ul>
<ol start="2">
<li>
<p>Content<br>
bootstrap的css样式和本身的site</p>
</li>
<li>
<p>fonts<br>
bootstrap 中的字体和图片</p>
</li>
<li>
<p>Scripts<br>
js文件</p>
</li>
<li>
<p>MVC</p>
</li>
</ol>
<ul>
<li>
<p>Models</p>
</li>
<li>
<p>Views</p>
<ul>
<li>
<p>Home       <em>与Controler一一对应</em></p>
</li>
<li>
<p>Shared</p>
<p>Layout 中的@renderbody即主题渲染,会用About中的文件替代</p>
</li>
</ul>
</li>
<li>
<p>Controllers</p>
</li>
</ul>
<blockquote>
<p>由地址栏访问控制器 通过models过滤 view中过滤然后显示出来</p>
</blockquote>
<h3 id="post和get">Post和Get</h3>
<p>用户访问网站为get方式,在提交某些数据后会通过post访问</p>
<pre><code class="language-html">
@{
    ViewBag.Title = &quot;AddNumbers&quot;;
    var total = 0;
    var totalMessage = &quot;&quot;;
    if (IsPost)
    {

        // Retrieve the numbers that the user entered.
        var num1 = Request[&quot;text1&quot;];
        var num2 = Request[&quot;text2&quot;];

        // Convert the entered strings into integers numbers and add.
        total = num1.AsInt() + num2.AsInt();
        totalMessage = &quot;Total = &quot; + total;
    }
}


&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;title&gt;Add Numbers&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        body {
            background-color: beige;
            font-family: Verdana, Arial;
            margin: 50px;
        }

        form {
            padding: 10px;
            border-style: solid;
            width: 250px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;Enter two whole numbers and then click &lt;strong&gt;Add&lt;/strong&gt;.&lt;/p&gt;
    &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
        &lt;p&gt;
            &lt;label for=&quot;text1&quot;&gt;First Number:&lt;/label&gt;
            &lt;input type=&quot;text&quot; name=&quot;text1&quot; /&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;label for=&quot;text2&quot;&gt;Second Number:&lt;/label&gt;
            &lt;input type=&quot;text&quot; name=&quot;text2&quot; /&gt;
        &lt;/p&gt;
        &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Add&quot; /&gt;&lt;/p&gt;
    &lt;/form&gt;

    &lt;p&gt;@totalMessage&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>视图模板不应执行业务逻辑或直接与数据库交互</strong>。 相反，视图模板应仅适用于控制器为其提供的数据。</p>
<p>ViewBag:   将控制器中的数据返回到视图页面.</p>
<p>例如在cs中声明ViewBag.msg = &quot;hello world&quot;;   那么在cshtml中@ViewBag.msg就会显示hello world</p>
<p>在控制器里面的数据怎么能在界面校验?</p>
<p>类的实例化应该在哪里实现?</p>
<p>httphelper 要用的时候查么?</p>
<p>using的三个用法:</p>
<ol>
<li>
<p>using+命名空间的名字</p>
</li>
<li>
<p>using+别名</p>
<p>​	using aClass=NameSpace1.MyClass</p>
<p>​	using bClass=NameSpace2.MyClass</p>
<p>​	好处是更加简洁</p>
</li>
<li>
<p>using  定义一个范围,在结束时处理对象.</p>
<p>用try catch也可以解决但是using更加方便</p>
</li>
</ol>
<p>解决方案是使用 <code>BeginForm</code> 的重载，该重载指定 POST 请求应将搜索信息添加到 URL，并且应将其路由到该 <code>HttpGet</code> 方法的版本 <code>Index</code> 。 将现有的无参数 <code>BeginForm</code> 方法替换为以下标记：</p>
<pre><code class="language-cshtml">@using (Html.BeginForm(&quot;Index&quot;,&quot;Movies&quot;,FormMethod.Get))
</code></pre>
<h2 id="构建解决方案">构建解决方案</h2>
<ul>
<li>Apps.Base
<ul>
<li>Apps.BLL (业务层)</li>
<li>Apps.IBLL (业务层<strong>接口</strong>)</li>
<li>Apps.DAL (数据层)</li>
<li>Apps.IDAL (数据层<strong>接口</strong>)</li>
</ul>
</li>
<li>Apps.Models (模型)</li>
<li>Apps.Common(通用类库)</li>
<li>Apps.Core (核心类库)</li>
<li>Apps.Locale(多语言文件)</li>
<li>Apps.WebApi(WebApi)</li>
<li>Apps.Web(UI层)</li>
</ul>
<h2 id="实体">实体</h2>
<ol>
<li>
<p>EF  操作数据库</p>
</li>
<li>
<p>DTO  传输数据</p>
<p>​	POCO原则(Plain Old C# Object扁平化C#类的对象)</p>
<p>​	扁平化：不能有对象出现</p>
</li>
<li>
<p>ViewModel   校验数据</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://yuusheng.github.io/about/</id>
        <link href="https://yuusheng.github.io/about/">
        </link>
        <updated>2021-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>​	这是一个个人博客</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>​	 博主是一个在校大学生</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>​	 兴趣爱好有点多诶 喜欢音乐喜欢编程 喜欢看偶像剧😜<br>
​	 最喜欢的明星是iu(漂亮还有才华也太棒了)<br>
​	 最喜欢的韩剧是《爱的迫降》《当你沉睡时》</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>​	 724845656@qq.com</p>
]]></content>
    </entry>
</feed>